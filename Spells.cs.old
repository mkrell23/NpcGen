// Generated by https://quicktype.io

namespace NpcGen
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Spells
    {
        [JsonProperty("index")]
        public string Index { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("desc")]
        public string[] Desc { get; set; }

        [JsonProperty("higher_level", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HigherLevel { get; set; }

        [JsonProperty("range")]
        public string Range { get; set; }

        [JsonProperty("components")]
        public Component[] Components { get; set; }

        [JsonProperty("material", NullValueHandling = NullValueHandling.Ignore)]
        public string Material { get; set; }

        [JsonProperty("ritual")]
        public bool Ritual { get; set; }

        [JsonProperty("duration")]
        public string Duration { get; set; }

        [JsonProperty("concentration")]
        public bool Concentration { get; set; }

        [JsonProperty("casting_time")]
        public string CastingTime { get; set; }

        [JsonProperty("level")]
        public long Level { get; set; }

        [JsonProperty("attack_type", NullValueHandling = NullValueHandling.Ignore)]
        public AttackType? AttackType { get; set; }

        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public Damage Damage { get; set; }

        [JsonProperty("school")]
        public School School { get; set; }

        [JsonProperty("classes")]
        public School[] Classes { get; set; }

        [JsonProperty("subclasses")]
        public School[] Subclasses { get; set; }

        [JsonProperty("url")]
        public string Url { get; set; }

        [JsonProperty("dc", NullValueHandling = NullValueHandling.Ignore)]
        public Dc Dc { get; set; }

        [JsonProperty("heal_at_slot_level", NullValueHandling = NullValueHandling.Ignore)]
        public HealAtSlotLevel? HealAtSlotLevel { get; set; }

        [JsonProperty("area_of_effect", NullValueHandling = NullValueHandling.Ignore)]
        public AreaOfEffect AreaOfEffect { get; set; }
    }

    public partial class AreaOfEffect
    {
        [JsonProperty("type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("size")]
        public long Size { get; set; }
    }

    public partial class School
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("url")]
        public string Url { get; set; }
    }

    public partial class Damage
    {
        [JsonProperty("damage_type", NullValueHandling = NullValueHandling.Ignore)]
        public School DamageType { get; set; }

        [JsonProperty("damage_at_slot_level", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> DamageAtSlotLevel { get; set; }

        [JsonProperty("damage_at_character_level", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> DamageAtCharacterLevel { get; set; }
    }

    public partial class Dc
    {
        [JsonProperty("dc_type")]
        public School DcType { get; set; }

        [JsonProperty("dc_success")]
        public DcSuccess DcSuccess { get; set; }

        [JsonProperty("desc", NullValueHandling = NullValueHandling.Ignore)]
        public string Desc { get; set; }
    }

    public enum TypeEnum { Cone, Cube, Cylinder, Line, Sphere };

    public enum AttackType { Melee, Ranged };

    public enum Component { M, S, V };

    public enum DcSuccess { Half, None, Other };

    public partial struct HealAtSlotLevel
    {
        public object[] AnythingArray;
        public Dictionary<string, string> StringMap;

        public static implicit operator HealAtSlotLevel(object[] AnythingArray) => new HealAtSlotLevel { AnythingArray = AnythingArray };
        public static implicit operator HealAtSlotLevel(Dictionary<string, string> StringMap) => new HealAtSlotLevel { StringMap = StringMap };
    }

    public partial class Spells
    {
        public static Spells[] FromJson(string json) => JsonConvert.DeserializeObject<Spells[]>(json, NpcGen.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Spells[] self) => JsonConvert.SerializeObject(self, NpcGen.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                TypeEnumConverter.Singleton,
                AttackTypeConverter.Singleton,
                ComponentConverter.Singleton,
                DcSuccessConverter.Singleton,
                HealAtSlotLevelConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "cone":
                    return TypeEnum.Cone;
                case "cube":
                    return TypeEnum.Cube;
                case "cylinder":
                    return TypeEnum.Cylinder;
                case "line":
                    return TypeEnum.Line;
                case "sphere":
                    return TypeEnum.Sphere;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Cone:
                    serializer.Serialize(writer, "cone");
                    return;
                case TypeEnum.Cube:
                    serializer.Serialize(writer, "cube");
                    return;
                case TypeEnum.Cylinder:
                    serializer.Serialize(writer, "cylinder");
                    return;
                case TypeEnum.Line:
                    serializer.Serialize(writer, "line");
                    return;
                case TypeEnum.Sphere:
                    serializer.Serialize(writer, "sphere");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class AttackTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AttackType) || t == typeof(AttackType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "melee":
                    return AttackType.Melee;
                case "ranged":
                    return AttackType.Ranged;
            }
            throw new Exception("Cannot unmarshal type AttackType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AttackType)untypedValue;
            switch (value)
            {
                case AttackType.Melee:
                    serializer.Serialize(writer, "melee");
                    return;
                case AttackType.Ranged:
                    serializer.Serialize(writer, "ranged");
                    return;
            }
            throw new Exception("Cannot marshal type AttackType");
        }

        public static readonly AttackTypeConverter Singleton = new AttackTypeConverter();
    }


    internal class ComponentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Component) || t == typeof(Component?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "M":
                    return Component.M;
                case "S":
                    return Component.S;
                case "V":
                    return Component.V;
            }
            throw new Exception("Cannot unmarshal type Component");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Component)untypedValue;
            switch (value)
            {
                case Component.M:
                    serializer.Serialize(writer, "M");
                    return;
                case Component.S:
                    serializer.Serialize(writer, "S");
                    return;
                case Component.V:
                    serializer.Serialize(writer, "V");
                    return;
            }
            throw new Exception("Cannot marshal type Component");
        }

        public static readonly ComponentConverter Singleton = new ComponentConverter();
    }

    internal class DcSuccessConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DcSuccess) || t == typeof(DcSuccess?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "half":
                    return DcSuccess.Half;
                case "none":
                    return DcSuccess.None;
                case "other":
                    return DcSuccess.Other;
            }
            throw new Exception("Cannot unmarshal type DcSuccess");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DcSuccess)untypedValue;
            switch (value)
            {
                case DcSuccess.Half:
                    serializer.Serialize(writer, "half");
                    return;
                case DcSuccess.None:
                    serializer.Serialize(writer, "none");
                    return;
                case DcSuccess.Other:
                    serializer.Serialize(writer, "other");
                    return;
            }
            throw new Exception("Cannot marshal type DcSuccess");
        }

        public static readonly DcSuccessConverter Singleton = new DcSuccessConverter();
    }

    internal class HealAtSlotLevelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HealAtSlotLevel) || t == typeof(HealAtSlotLevel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, string>>(reader);
                    return new HealAtSlotLevel { StringMap = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new HealAtSlotLevel { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type HealAtSlotLevel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (HealAtSlotLevel)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.StringMap != null)
            {
                serializer.Serialize(writer, value.StringMap);
                return;
            }
            throw new Exception("Cannot marshal type HealAtSlotLevel");
        }

        public static readonly HealAtSlotLevelConverter Singleton = new HealAtSlotLevelConverter();
    }
}
