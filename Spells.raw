// Generated by https://quicktype.io

namespace NpcGen
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Spells
    {
        [JsonProperty("index")]
        public string Index { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("desc")]
        public string[] Desc { get; set; }

        [JsonProperty("higher_level", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HigherLevel { get; set; }

        [JsonProperty("range")]
        public Range Range { get; set; }

        [JsonProperty("components")]
        public Component[] Components { get; set; }

        [JsonProperty("material", NullValueHandling = NullValueHandling.Ignore)]
        public string Material { get; set; }

        [JsonProperty("ritual")]
        public bool Ritual { get; set; }

        [JsonProperty("duration")]
        public string Duration { get; set; }

        [JsonProperty("concentration")]
        public bool Concentration { get; set; }

        [JsonProperty("casting_time")]
        public CastingTime CastingTime { get; set; }

        [JsonProperty("level")]
        public long Level { get; set; }

        [JsonProperty("attack_type", NullValueHandling = NullValueHandling.Ignore)]
        public AttackType? AttackType { get; set; }

        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public Damage Damage { get; set; }

        [JsonProperty("school")]
        public School School { get; set; }

        [JsonProperty("classes")]
        public School[] Classes { get; set; }

        [JsonProperty("subclasses")]
        public School[] Subclasses { get; set; }

        [JsonProperty("url")]
        public string Url { get; set; }

        [JsonProperty("dc", NullValueHandling = NullValueHandling.Ignore)]
        public Dc Dc { get; set; }

        [JsonProperty("heal_at_slot_level", NullValueHandling = NullValueHandling.Ignore)]
        public HealAtSlotLevel? HealAtSlotLevel { get; set; }

        [JsonProperty("area_of_effect", NullValueHandling = NullValueHandling.Ignore)]
        public AreaOfEffect AreaOfEffect { get; set; }
    }

    public partial class AreaOfEffect
    {
        [JsonProperty("type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("size")]
        public long Size { get; set; }
    }

    public partial class School
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("url")]
        public string Url { get; set; }
    }

    public partial class Damage
    {
        [JsonProperty("damage_type", NullValueHandling = NullValueHandling.Ignore)]
        public School DamageType { get; set; }

        [JsonProperty("damage_at_slot_level", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> DamageAtSlotLevel { get; set; }

        [JsonProperty("damage_at_character_level", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> DamageAtCharacterLevel { get; set; }
    }

    public partial class Dc
    {
        [JsonProperty("dc_type")]
        public School DcType { get; set; }

        [JsonProperty("dc_success")]
        public DcSuccess DcSuccess { get; set; }

        [JsonProperty("desc", NullValueHandling = NullValueHandling.Ignore)]
        public string Desc { get; set; }
    }

    public enum TypeEnum { Cone, Cube, Cylinder, Line, Sphere };

    public enum AttackType { Melee, Ranged };

    public enum CastingTime { The10Minutes, The12Hours, The1Action, The1BonusAction, The1Hour, The1Minute, The1Reaction, The24Hours, The8Hours };

    public enum Component { M, S, V };

    public enum DcSuccess { Half, None, Other };

    public enum Range { Self, Sight, Special, The100Feet, The10Feet, The120Feet, The150Feet, The1Mile, The300Feet, The30Feet, The500Feet, The500Miles, The5Feet, The60Feet, The90Feet, Touch, Unlimited };

    public partial struct HealAtSlotLevel
    {
        public object[] AnythingArray;
        public Dictionary<string, string> StringMap;

        public static implicit operator HealAtSlotLevel(object[] AnythingArray) => new HealAtSlotLevel { AnythingArray = AnythingArray };
        public static implicit operator HealAtSlotLevel(Dictionary<string, string> StringMap) => new HealAtSlotLevel { StringMap = StringMap };
    }

    public partial class Spells
    {
        public static Spells[] FromJson(string json) => JsonConvert.DeserializeObject<Spells[]>(json, NpcGen.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Spells[] self) => JsonConvert.SerializeObject(self, NpcGen.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                TypeEnumConverter.Singleton,
                AttackTypeConverter.Singleton,
                CastingTimeConverter.Singleton,
                ComponentConverter.Singleton,
                DcSuccessConverter.Singleton,
                HealAtSlotLevelConverter.Singleton,
                RangeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "cone":
                    return TypeEnum.Cone;
                case "cube":
                    return TypeEnum.Cube;
                case "cylinder":
                    return TypeEnum.Cylinder;
                case "line":
                    return TypeEnum.Line;
                case "sphere":
                    return TypeEnum.Sphere;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Cone:
                    serializer.Serialize(writer, "cone");
                    return;
                case TypeEnum.Cube:
                    serializer.Serialize(writer, "cube");
                    return;
                case TypeEnum.Cylinder:
                    serializer.Serialize(writer, "cylinder");
                    return;
                case TypeEnum.Line:
                    serializer.Serialize(writer, "line");
                    return;
                case TypeEnum.Sphere:
                    serializer.Serialize(writer, "sphere");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class AttackTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AttackType) || t == typeof(AttackType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "melee":
                    return AttackType.Melee;
                case "ranged":
                    return AttackType.Ranged;
            }
            throw new Exception("Cannot unmarshal type AttackType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AttackType)untypedValue;
            switch (value)
            {
                case AttackType.Melee:
                    serializer.Serialize(writer, "melee");
                    return;
                case AttackType.Ranged:
                    serializer.Serialize(writer, "ranged");
                    return;
            }
            throw new Exception("Cannot marshal type AttackType");
        }

        public static readonly AttackTypeConverter Singleton = new AttackTypeConverter();
    }

    internal class CastingTimeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CastingTime) || t == typeof(CastingTime?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "1 action":
                    return CastingTime.The1Action;
                case "1 bonus action":
                    return CastingTime.The1BonusAction;
                case "1 hour":
                    return CastingTime.The1Hour;
                case "1 minute":
                    return CastingTime.The1Minute;
                case "1 reaction":
                    return CastingTime.The1Reaction;
                case "10 minutes":
                    return CastingTime.The10Minutes;
                case "12 hours":
                    return CastingTime.The12Hours;
                case "24 hours":
                    return CastingTime.The24Hours;
                case "8 hours":
                    return CastingTime.The8Hours;
            }
            throw new Exception("Cannot unmarshal type CastingTime");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CastingTime)untypedValue;
            switch (value)
            {
                case CastingTime.The1Action:
                    serializer.Serialize(writer, "1 action");
                    return;
                case CastingTime.The1BonusAction:
                    serializer.Serialize(writer, "1 bonus action");
                    return;
                case CastingTime.The1Hour:
                    serializer.Serialize(writer, "1 hour");
                    return;
                case CastingTime.The1Minute:
                    serializer.Serialize(writer, "1 minute");
                    return;
                case CastingTime.The1Reaction:
                    serializer.Serialize(writer, "1 reaction");
                    return;
                case CastingTime.The10Minutes:
                    serializer.Serialize(writer, "10 minutes");
                    return;
                case CastingTime.The12Hours:
                    serializer.Serialize(writer, "12 hours");
                    return;
                case CastingTime.The24Hours:
                    serializer.Serialize(writer, "24 hours");
                    return;
                case CastingTime.The8Hours:
                    serializer.Serialize(writer, "8 hours");
                    return;
            }
            throw new Exception("Cannot marshal type CastingTime");
        }

        public static readonly CastingTimeConverter Singleton = new CastingTimeConverter();
    }

    internal class ComponentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Component) || t == typeof(Component?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "M":
                    return Component.M;
                case "S":
                    return Component.S;
                case "V":
                    return Component.V;
            }
            throw new Exception("Cannot unmarshal type Component");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Component)untypedValue;
            switch (value)
            {
                case Component.M:
                    serializer.Serialize(writer, "M");
                    return;
                case Component.S:
                    serializer.Serialize(writer, "S");
                    return;
                case Component.V:
                    serializer.Serialize(writer, "V");
                    return;
            }
            throw new Exception("Cannot marshal type Component");
        }

        public static readonly ComponentConverter Singleton = new ComponentConverter();
    }

    internal class DcSuccessConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DcSuccess) || t == typeof(DcSuccess?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "half":
                    return DcSuccess.Half;
                case "none":
                    return DcSuccess.None;
                case "other":
                    return DcSuccess.Other;
            }
            throw new Exception("Cannot unmarshal type DcSuccess");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DcSuccess)untypedValue;
            switch (value)
            {
                case DcSuccess.Half:
                    serializer.Serialize(writer, "half");
                    return;
                case DcSuccess.None:
                    serializer.Serialize(writer, "none");
                    return;
                case DcSuccess.Other:
                    serializer.Serialize(writer, "other");
                    return;
            }
            throw new Exception("Cannot marshal type DcSuccess");
        }

        public static readonly DcSuccessConverter Singleton = new DcSuccessConverter();
    }

    internal class HealAtSlotLevelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HealAtSlotLevel) || t == typeof(HealAtSlotLevel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, string>>(reader);
                    return new HealAtSlotLevel { StringMap = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new HealAtSlotLevel { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type HealAtSlotLevel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (HealAtSlotLevel)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.StringMap != null)
            {
                serializer.Serialize(writer, value.StringMap);
                return;
            }
            throw new Exception("Cannot marshal type HealAtSlotLevel");
        }

        public static readonly HealAtSlotLevelConverter Singleton = new HealAtSlotLevelConverter();
    }

    internal class RangeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Range) || t == typeof(Range?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "1 mile":
                    return Range.The1Mile;
                case "10 feet":
                    return Range.The10Feet;
                case "100 feet":
                    return Range.The100Feet;
                case "120 feet":
                    return Range.The120Feet;
                case "150 feet":
                    return Range.The150Feet;
                case "30 feet":
                    return Range.The30Feet;
                case "300 feet":
                    return Range.The300Feet;
                case "5 feet":
                    return Range.The5Feet;
                case "500 feet":
                    return Range.The500Feet;
                case "500 miles":
                    return Range.The500Miles;
                case "60 feet":
                    return Range.The60Feet;
                case "90 feet":
                    return Range.The90Feet;
                case "Self":
                    return Range.Self;
                case "Sight":
                    return Range.Sight;
                case "Special":
                    return Range.Special;
                case "Touch":
                    return Range.Touch;
                case "Unlimited":
                    return Range.Unlimited;
            }
            throw new Exception("Cannot unmarshal type Range");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Range)untypedValue;
            switch (value)
            {
                case Range.The1Mile:
                    serializer.Serialize(writer, "1 mile");
                    return;
                case Range.The10Feet:
                    serializer.Serialize(writer, "10 feet");
                    return;
                case Range.The100Feet:
                    serializer.Serialize(writer, "100 feet");
                    return;
                case Range.The120Feet:
                    serializer.Serialize(writer, "120 feet");
                    return;
                case Range.The150Feet:
                    serializer.Serialize(writer, "150 feet");
                    return;
                case Range.The30Feet:
                    serializer.Serialize(writer, "30 feet");
                    return;
                case Range.The300Feet:
                    serializer.Serialize(writer, "300 feet");
                    return;
                case Range.The5Feet:
                    serializer.Serialize(writer, "5 feet");
                    return;
                case Range.The500Feet:
                    serializer.Serialize(writer, "500 feet");
                    return;
                case Range.The500Miles:
                    serializer.Serialize(writer, "500 miles");
                    return;
                case Range.The60Feet:
                    serializer.Serialize(writer, "60 feet");
                    return;
                case Range.The90Feet:
                    serializer.Serialize(writer, "90 feet");
                    return;
                case Range.Self:
                    serializer.Serialize(writer, "Self");
                    return;
                case Range.Sight:
                    serializer.Serialize(writer, "Sight");
                    return;
                case Range.Special:
                    serializer.Serialize(writer, "Special");
                    return;
                case Range.Touch:
                    serializer.Serialize(writer, "Touch");
                    return;
                case Range.Unlimited:
                    serializer.Serialize(writer, "Unlimited");
                    return;
            }
            throw new Exception("Cannot marshal type Range");
        }

        public static readonly RangeConverter Singleton = new RangeConverter();
    }
}
